\documentclass[../diss.tex]{subfiles}

\begin{document}

My project concerns the creation of a generational garbage collector for the C programming language. I have produced a library which programmers can add to their software that enables garbage collection. The overall implementation has been very successful and I have met the core success criteria. As well as this I have implemented an extension to the project to make the garbage collector thread-safe. Throughout this dissertation I will discuss the motivations, theory, implementation and evaluation.

\section{Motivation and Aims}

Programming languages tend to either use manual memory management or automatic memory management. Each have their respective advantages and disadvantages which are discussed here. We will see that adding features of automatic memory management into a manual memory-managed language such as C can be desirable.

Manual memory-managed languages give the programmer total control over when objects are allocated and deallocated. Typically this is preferred in situations where performance is of the utmost importance. However, reasoning about when to free memory is sometimes difficult for the programmer and forgetting to do so will result in a memory leak. Memory leaks can cause long-running programs to crash and can even be used to provide denial of service attacks if the attacker can find a sequence of actions which trigger a leak. Automatic memory management, and in particular garbage collection, was invented to prevent memory leaks in situations where we can tolerate the performance overhead. In addition to the performance overhead, garbage collectors have their own storage requirements making them impractical on low-memory devices.

When we start a new project a requirements analysis is performed and the conclusions from this may state that a language with a particular memory management model should be preferred. For this reason it may be desirable to be able to add garbage collection to a language without support for it. Thus, regardless of the requirements we can use the same language which may be preferred among the existing team. 

The aim of my project is to create a library for C which replaces the manual memory management functions to provide garbage collection features. There already exists solutions (\cref{sec:furtherwork}) but as I mentioned previously there are many different garbage collection algorithms, my library will use a generational algorithm (see \cref{sec:generationalgarbagecollection}). Garbage collector libraries of this form can also be easily modified to make useful leak detectors which can be used as debugging tools. Similarly, they can be used as teaching tools to demonstrate many features of operating systems, garbage collectors and algorithms. I will release my garbage collector as open-source software on GitHub with an MIT license. The reason behind this is that this form of software can benefit greatly from platform-specific code to improve performance. Allowing other software engineers who have expertise in specific platforms to use and edit the code will benefit other users greatly. The MIT license matches my intentions as it allows others to modify and distribute the source code as well as use it in commercial projects which should help to improve the project.

\section{Challenges}

Adding garbage collection to languages which never intended to have it as a feature poses many challenges. Several of these stem from the fact that we have no compiler support. Firstly, we must be able to find pointers from a set of starting memory contents known as the root set (see \cref{sec:gctheory}) but we can not tell the difference between pointers and any arbitrary bits in memory (see \cref{lab:conservative}). A key feature of the generational algorithm is the write-barrier (see \cref{sec:prepwritebarriers}) which usually is implemented in the compiler or in hardware but this is not possible with a library. Furthermore, a user may intend to add garbage collection to an existing project, thus we require that the garbage collector be portable (or as portable as possibly can be). Making the garbage collector thread-safe is another challenge, and choosing the best approach is a challenge in itself due to the choice of options (see \cref{sec:multithreadingmodels}). 

Evaluating my project comprises running the garbage collector on various C benchmarks and consolidating the results. For the benchmarks to be suitable they must demonstrate that the key features of the garbage collector work as expected. Common C benchmarks tend to focus more on being CPU intensive and only allocate long-lived objects on the heap, which is not very useful for highlighting the advantages of a generational algorithm. The solution to this was to create my own benchmarks which allocate memory in such a way that it enables me to draw conclusion about the success of the garbage collector. These benchmarks are discussed in \cref{sec:benchmarks}.

\section{Related Work} \label{sec:furtherwork}

The Boehm-Demers-Weiser garbage collector\footnote{http://www.hboehm.info/gc/} is an existing solution which uses a mark and sweep algorithm (see \cref{sec:markandsweep}). It also has a generational mode but the key differences are that my garbage collector focuses on this from the outset and handles multi-threaded applications differently. My solution uses a stop-the-world algorithm whereas the Boehm collector uses an incremental algorithm. These are discussed in \cref{sec:multithreadingmodels} but the key point is that stop-the-world approaches are better for non-interactive programs and vice-versa.

\end{document}